-- Vehicle Blinkshot

declare global.object[0]
alias previous_vehicle = global.object[0] -- Used to store the previous player's vehicle.

-- object.object[0] is a flag that determines wether a telporter spawnpoint has a teleporter.

declare player.object[0] -- Used to store the hill marker, where the vehicle and the players are gonna be teleported.
declare player.object[1] -- Used to store the vehicles that has to be teleported with the players.
declare player.object[2] -- Used to store the temporal biped.
declare player.object[3] -- Used to store the real player's biped.

declare player.number[0] -- Flag: Determines wether the player is prepared to be teleported.
declare player.number[1] -- Used to count ticks.

function handle_teleporters_spawnpoint()
    for each object with label "teleporter_spawnpoint" do
        if current_object.object[0] == no_object then -- If "teleporter" doesn't exists on this "teleporter_spawnpoint".
            alias teleporter = allocate global.object -- Monitor that it's attached to the attachable objects.

            current_object.timer[0].set_rate(100%) -- Starts the timer to spawn the "teleporter" again.
            
            if current_object.timer[0] >= 3 then
                teleporter = current_object.place_at_me(monitor, "teleporter", never_garbage_collect, 0, 0, 0, default)
                teleporter.object[0] = current_object

                if current_object.spawn_sequence == 0 then
                    teleporter.set_waypoint_visibility(everyone)
                    teleporter.set_waypoint_range(10, 100)
                    teleporter.set_scale(300)

                altif current_object.spawn_sequence == 1 then
                    teleporter.set_waypoint_text("Need a vehicle!")
                    teleporter.set_waypoint_visibility(everyone)
                    teleporter.set_waypoint_priority(low)
                    teleporter.set_waypoint_range(0, 30)
                    teleporter.set_scale(500)
                end

                current_object.object[0] = teleporter -- Save the "teleporter", inside the "teleporter_spawnpoint".
                current_object.timer[0].set_rate(0%) -- Stops the timer to spawn the "teleporter" again.
                current_object.timer[0] = 0 -- Sets the timer value to zero.
            end
        end
    end
end 

function handle_monitors_health()
    for each object with label "teleporter" do
        alias monitor_state = allocate global.number

        monitor_state = current_object.shields
        if monitor_state > 0 then
            current_object.shields = 0
        end

        monitor_state = current_object.health
        if monitor_state > 1 then
            current_object.health = 1
        end

        alias teleporter_spawner = allocate global.object
        teleporter_spawner = current_object.object[0]

        if teleporter_spawner.spawn_sequence == 0 then
            current_object.set_waypoint_text("Destroy!")
            current_object.set_waypoint_priority(low)
        end
    end
end

function save_players_on_same_vehicle()
    alias this_player = allocate global.player

    this_player = current_player
    this_player.object[1] = current_player.get_vehicle()

    if this_player.object[1] != no_object then -- If this player has a vehicle.
        for each player do
            if this_player != current_player then -- If the current player is different from 'this_player'.
                current_player.object[1] = current_player.get_vehicle() -- Save the current player's vehicle.
        
                if this_player.object[1] == current_player.object[1] then -- If this two players are on the same vehicle.
                    if this_player.player[0] == no_player then 
                        this_player.player[0] = current_player -- Save the current player inside 'this_player'.

                    altif this_player.player[1] == no_player then
                        if this_player.player[0] != current_player then -- To not save the same player two times.
                            this_player.player[1] = current_player -- Save the current player inside 'this_player'.
                        end
                    end

                altif this_player.object[1] != current_player.object[1] then -- If these player are not in the same vehicle.
                    if this_player.player[0] == current_player then -- If the current player is saved inside 'this_player' data.
                        this_player.player[0] = no_player -- Remove it.
                    
                    altif this_player.player[1] == current_player then -- If the current player is saved inside 'this_player' data.
                        this_player.player[1] = no_player -- Remove it.
                    end
                end
            end
        end
    end
end

function create_new_vehicle()
    for each object with label "vehicle" do
        if current_object.player[0] == current_player then
            current_object.player[0] = no_player
        end
    end

    if previous_vehicle.is_of_type(warthog) then -- If this player is on a warthog.
        current_player.object[1] = current_player.object[0].place_at_me(warthog, "vehicle", none, 0, 0, 0, none) -- Create another instance of the player's vehicle

    altif previous_vehicle.is_of_type(ghost) then -- If this player is on a ghost.
        current_player.object[1] = current_player.object[0].place_at_me(ghost, "vehicle", none, 0, 0, 0, none) -- Create another instance of the player's vehicle
                
    altif previous_vehicle.is_of_type(revenant) then -- If this player is on a revenant.
        current_player.object[1] = current_player.object[0].place_at_me(revenant, "vehicle", none, 0, 0, 0, none) -- Create another instance of the player's vehicle
                
    altif previous_vehicle.is_of_type(mongoose) then -- If this player is on a mongoose.
        current_player.object[1] = current_player.object[0].place_at_me(mongoose, "vehicle", none, 0, 0, 0, none) -- Create another instance of the player's vehicle
    end

    current_player.object[0].delete() -- Delete the hill marker saved on this variable.
    current_player.object[0] = no_object -- Clear this variable.
end

function prepare_players_teleport()
    alias temporal_player = allocate global.player

    current_player.biped.detach() -- Make this player leave his vehicle.
    current_player.number[0] = 1 -- Flag: First part of teleportation completed.
    current_player.number[1] = 0 -- Flag: Set the tick counter to zero.
                
    if current_player.player[0] != no_player then -- If there's a second player on the vehicle.
        temporal_player = current_player.player[0]

        temporal_player.object[1] = current_player.object[1] -- Save the vehicle teleported on this player's data.
        temporal_player.biped.detach() -- Make this player leave his vehicle.
        temporal_player.number[0] = 1 -- Flag: First part of teleportation completed.
        temporal_player.number[1] = 0 -- Flag: Set the tick counter to zero.
    end

    if current_player.player[1] != no_player then -- If there's a third player on the vehicle.
        temporal_player = current_player.player[1]

        temporal_player.object[1] = current_player.object[1] -- Save the vehicle teleported on this player's data.
        temporal_player.biped.detach() -- Make this player leave his vehicle.
        temporal_player.number[0] = 1 -- Flag: First part of teleportation completed.
        temporal_player.number[1] = 0 -- Flag: Set the tick counter to zero.
    end

    previous_vehicle.delete() -- Delete the previous player's vehicle.
    previous_vehicle = no_object -- Cleaning.
    temporal_player = no_player -- Cleaning.
end

function teleport_players_to_vehicle()
    current_player.number[1] += 1 -- Increase the ticks counter.

    if current_player.number[1] == 1 then -- If this is the first tick since teleportation started.
        current_player.object[2] = no_object
        current_player.object[2] = current_player.object[1].place_at_me(monitor, "trash", none, 0, 0, 60, none) -- Create a monitor close to the new vehicle.
        current_player.object[3] = current_player.biped -- Save the real player's biped.
                
        current_player.set_biped(current_player.object[2]) -- Set the monitor as the new biped of this player.
        current_player.biped.remove_weapon(primary, true)

    altif current_player.number[1] == 2 then -- If this is the second tick since teleportation started.
        current_player.object[3].attach_to(current_player.object[1], 30, 0, 30, relative) -- Move the real player's biped closer to the vehicle.
        current_player.object[3].detach()

        current_player.set_biped(current_player.object[3]) -- Return the player to it's real biped.
                
    altif current_player.number[1] == 3 then -- If this is the third tick since teleportation started.
        current_player.object[2].delete() -- Delete the monitor created.

        current_player.force_into_vehicle(current_player.object[1]) -- Force this player into this new vehicle.
        
        current_player.object[1] = no_object -- Clear the player vehicle.
        current_player.object[2] = no_object -- Clear the temporal player's biped.
        current_player.object[3] = no_object -- Clear the real player's biped.
        current_player.number[0] = 0 -- Clear the 'is prepared to teleport' flag.
        current_player.number[1] = 0 -- Clear the ticks counter.
    end
end

function clear_saved_players()
    current_player.player[0] = no_player -- Cleaning.
    current_player.player[1] = no_player -- Cleaning.
end

function handle_vehicles_teleportation() -- Main function.
    for each player do
        clear_saved_players()

        if current_player.object[0] != no_object then -- If this player on a vehicle destroyed a monitor.
            save_players_on_same_vehicle()

            if current_player.object[1] != no_object then -- If this player is on a vehicle.
                previous_vehicle = current_player.object[1] -- Save the previous vehicle of this player.

                create_new_vehicle()
                prepare_players_teleport()
            end
        end

        if current_player.number[0] == 1 then
            teleport_players_to_vehicle()
        end
    end
end

do
    handle_teleporters_spawnpoint()
    handle_vehicles_teleportation()
    handle_monitors_health()
end

on object death: do
    if killed_object.has_forge_label("teleporter") then -- If the object destroyed has the "teleporter" label.
        alias distance = allocate global.number
        distance = killed_object.get_distance_to(killer_player.biped)
        
        if distance <= 200 then
            alias temporal_vehicle = allocate global.object
            temporal_vehicle = killer_player.get_vehicle() -- Get the current player's vehicle.

            if temporal_vehicle != no_object then -- If this player has a vehicle.
                killer_player.object[0] = killed_object.place_at_me(hill_marker, none, never_garbage_collect, 0, 0, 0, none) -- Create the object where the player it's going to attach/teleport.

            altif temporal_vehicle == no_object then -- If this player doesn't have a vehicle.
                killer_player.object[0] = no_object -- Cleaning.
            end
            
            temporal_vehicle = no_object -- Cleaning.
            script_widget[0].set_visibility(killer_player, false)

        altif distance > 200 then
            script_widget[0].set_text("Get closer!")
            script_widget[0].set_visibility(killer_player, true)
        end
    end
end

-- Vehicle Blinkshot










-- Initialization

function handle_waypoints()
    for each object with label "teleporter" do
        if current_object.is_of_type(hill_marker) then
            if current_object.spawn_sequence == 0 then
                current_object.set_waypoint_visibility(everyone)
                current_object.set_waypoint_text("To road")
                current_object.set_waypoint_priority(low)
                current_object.set_waypoint_range(0, 50)
            end
        end
    end
end

do
    handle_waypoints()
end

-- Initialization










-- Checkpoint System: re-write all this shit based on what race gt does.

on init: do
    for each player do
        current_player.number[2] = -1
        current_player.set_fireteam(0)

        script_widget[1].set_visibility(current_player, false)
        --script_widget[2].set_visibility(current_player, false)
    end

    for each object with label "checkpoint" do
        current_object.team = team[1] -- Puts color to this waypoint.

        current_object.set_spawn_location_permissions(no_one) -- No one can spawn here.
        current_object.set_shape_visibility(no_one) -- Hides this object shape.
        current_object.set_invincibility(1) -- This object is invincible.
        
        current_object.set_waypoint_text("%nm", hud_player.number[5]) -- Shows the distance to the next checkpoint.
        current_object.set_waypoint_visibility(no_one) -- Hides this object waypoint.
        current_object.set_waypoint_priority(blink) -- Sets this waypoint to blink.
        current_object.set_waypoint_icon(diamond) -- Sets this waypoint icon to 'diamond'.
    end
end

function handle_next_checkpoint()
    alias next_checkpoint = allocate global.number
    next_checkpoint = current_player.number[2]
    next_checkpoint += 1

    alias last_checkpoint = allocate global.number -- Maybe it has to be local.
    last_checkpoint = 0

    for each object with label "checkpoint" do
        if last_checkpoint < current_object.spawn_sequence then
            last_checkpoint = current_object.spawn_sequence
        end
    end

    if next_checkpoint > last_checkpoint then
        current_player.number[2] = -1
        next_checkpoint = 0
    end

    if next_checkpoint == current_object.spawn_sequence then
        -- Shows this waypoint to this player. 
        current_object.set_waypoint_visibility(mod_player, current_player, 1)

        -- Shows this object shape to this player.  
        current_object.set_shape_visibility(mod_player, current_player, 1)

        -- Calculate next checkpoint distance.
        current_player.number[5] = 0
        current_player.number[5] = current_player.biped.get_distance_to(current_object)
        current_player.number[5] *= 7
        current_player.number[5] /= 23
    end
end

function save_player_vehicle()
    alias player_vehicle = allocate global.object
    player_vehicle = current_player.get_vehicle()

    if player_vehicle.is_of_type(ghost) then
        current_player.number[6] = 1 -- This player has a ghost.

    altif player_vehicle.is_of_type(mongoose) then
        current_player.number[6] = 2 -- This player has a mongoose.
    
    altif player_vehicle.is_of_type(revenant) then
        current_player.number[6] = 3 -- This player has a revenant.
    
    altif player_vehicle.is_of_type(warthog) then
        current_player.number[6] = 4 -- This player has a warthog.
    end
end

function set_player_fireteam()
    save_players_on_same_vehicle()

    alias this_player = allocate global.player
    this_player = current_player

    alias this_player_fireteam = allocate global.number
    this_player_fireteam = current_player.get_fireteam()

    if this_player_fireteam == 0 then
        for each player do
            if current_player != this_player then
                alias player_fireteam = allocate global.number
                player_fireteam = current_player.get_fireteam()
                
                if player_fireteam == this_player_fireteam then
                    this_player_fireteam += 1
                end
            end
        end
    end

    current_player.set_fireteam(this_player_fireteam)
    current_player.player[0].set_fireteam(this_player_fireteam)
    current_player.player[1].set_fireteam(this_player_fireteam)

    clear_saved_players()
end

function handle_checkpoint_reached()
    -- Set this checkpoint as the current player's checkpoint.
    current_player.number[2] = current_object.spawn_sequence
                
    -- Hides this waypoint to this player. 
    current_object.set_waypoint_visibility(mod_player, current_player, 0)

    -- Hides this object shape to this player.
    current_object.set_shape_visibility(mod_player, current_player, 0)

    -- If this is the first checkpoint.
    if current_object.spawn_sequence == 0 then
        current_player.number[4] = 0 -- Reset this flag.    

        -- If this is the first player's lap.
        if current_player.number[3] == 0 then
            send_incident(race_game_start, current_player, no_player)
            current_player.timer[0].set_rate(100%)
            script_widget[1].set_visibility(current_player, true)
            --script_widget[2].set_visibility(current_player, true)

            save_player_vehicle()
            set_player_fireteam()

            -- If this is not the first player's lap.
        altif current_player.number[3] > 0 then
            alias last_lap = allocate global.number
            last_lap = script_option[0]
            last_lap -= 2

            -- If this is not the last lap.
            if current_player.number[3] != last_lap then
                -- This player has completed a lap.
                send_incident(lap_complete, current_player, no_player)
                game.show_message_to(current_player, none, "Lap Complete.")
                current_player.timer[0].reset()

            -- If this is the last lap.
            altif current_player.number[3] == last_lap then
                -- This player is on the final lap.
                send_incident(final_lap, current_player, all_players)
                game.show_message_to(current_player, none, "Final lap.")
            
            altif current_player.number[3] == script_option[0] then
                game.end_round()
            end
        end
        
        current_player.number[3] += 1 -- Increase this player's lap counter.

    altif current_object.spawn_sequence > 0 then
        send_incident(checkpoint_reached, current_player, no_player)
        current_player.score += 1
    end

    alias last_checkpoint = allocate global.number -- Maybe it has to be local.
    last_checkpoint = 0

    for each object with label "checkpoint" do
        if last_checkpoint < current_object.spawn_sequence then
            last_checkpoint = current_object.spawn_sequence
        end
    end

    if current_object.spawn_sequence == last_checkpoint then
        current_player.number[4] = 1 -- Flag: this player just passed the last checkpoint.
    end
end

function handle_checkpoint_respawn()
    -- If this checkpoint is the current player's checkpoint.
    if current_object.spawn_sequence == current_player.number[2] then
        -- Convert this object as the only respawn point for this player.
        current_object.set_spawn_location_permissions(mod_player, current_player, 1)
        current_player.set_primary_respawn_object(current_object)

        -- If this player is not being teleportated.
        if current_player.number[0] == 0 then
            current_player.object[2] = no_object
            current_player.object[2] = current_player.get_vehicle()

            for each object with label "vehicle" do
                if current_object.player[0] == current_player then
                    current_object.player[0] = no_player
                end
            end

            -- If this player doesn't have a vehicle.
            if current_player.object[2] == no_object then
                -- If this player had a ghost.
                if current_player.number[6] == 1 then
                    current_player.object[2] = current_object.place_at_me(ghost, "vehicle", none, 0, 0, 0, none)

                -- If this player had a mongoose.
                altif current_player.number[6] == 2 then
                    current_player.object[2] = current_object.place_at_me(mongoose, "vehicle", none, 0, 0, 0, none)
                
                -- If this player had a revenant.
                altif current_player.number[6] == 3 then
                    current_player.object[2] = current_object.place_at_me(revenant, "vehicle", none, 0, 0, 0, none)
                
                -- If this player had a warthog.
                altif current_player.number[6] == 4 then
                    current_player.object[2] = current_object.place_at_me(warthog, "vehicle", none, 0, 0, 0, none)
                end
                
                current_player.force_into_vehicle(current_player.object[2])
                
                alias this_player = allocate global.player
                this_player = current_player

                alias this_player_fireteam = allocate global.number
                this_player_fireteam = current_player.get_fireteam()

                for each player do
                    if current_player != this_player then
                        alias player_fireteam = allocate global.number
                        player_fireteam = current_player.get_fireteam()

                        if player_fireteam == this_player_fireteam then
                            alias player_vehicle = allocate global.object
                            player_vehicle = current_player.get_vehicle()

                            if player_vehicle == no_object then
                                current_player.force_into_vehicle(this_player.object[2])
                                
                            altif player_vehicle != no_object then
                                if player_vehicle != this_player.object[2] then
                                    current_player.biped.detach()
                                    current_player.force_into_vehicle(this_player.object[2])

                                    player_vehicle.delete()
                                    player_vehicle = no_object
                                end
                            end
                        end
                    end
                end
            end
        end

        current_player.object[2] = no_object
    
    -- If this checkpoint is not the current player's checkpoint.
    altif current_object.spawn_sequence != current_player.number[2] then
        current_object.set_spawn_location_permissions(mod_player, current_player, 0)
    end
end

function handle_checkpoints()
    for each object with label "checkpoint" do
        current_object.set_spawn_location_permissions(no_one)
        current_object.set_invincibility(1)

        handle_next_checkpoint()

        -- If this player hasn't reached this and the last checkpoint.
        if current_player.number[2] < current_object.spawn_sequence then
            -- If this is the first checkpoint or the player haven't reached the last checkpoint.
            if current_object.spawn_sequence == 0 or current_player.number[4] == 0 then
                alias player_vehicle = allocate global.object
                player_vehicle = current_player.get_vehicle()

                -- If this checkpoint's shape contains this player and this player have a vehicle..
                if current_object.shape_contains(current_player.biped) and player_vehicle != no_object then
                    handle_checkpoint_reached()
                end
            end
        end

        if current_player.biped != no_object then
            handle_checkpoint_respawn()
        end
    end
end

function handle_laps()
    alias last_lap = allocate global.number
    last_lap = script_option[0]
    last_lap -= 1

    alias current_lap = allocate global.number
    current_lap = current_player.number[3]  

    --script_widget[1].set_text("Lap %n/%n", current_lap, last_lap)
end

for each player do
    current_player.set_co_op_spawning(true)
    current_player.biped.set_spawn_location_permissions(no_one)

    handle_checkpoints()
    handle_laps()

    alias lap_time = allocate global.timer
    lap_time = current_player.timer[0]

    --script_widget[2].set_text("Lap time %n", lap_time)

    -- If this player has completed all the laps.
    if current_player.number[3] >= script_option[0] then
        game.end_round()
    end
end

for each object with label "trash" do
    current_object.timer[0].set_rate(100%)

    if current_object.timer[0] > 1 then
        current_object.delete()
    end
end

for each object with label "spawn_area" do
    alias spawn_area = allocate global.object
    spawn_area = current_object

    for each object with label "vehicle" do  
        if not spawn_area.shape_contains(current_object) then
            alias player_vehicle = allocate global.object
            
            for each player do
                player_vehicle = current_player.get_vehicle()
                
                if current_object == player_vehicle then
                    player_vehicle.player[0] = current_player
                end
            end
        
            if current_object.player[0] == no_player then
                current_object.timer[0].set_rate(100%)
            
            altif current_object.player[0] != no_player then
                current_object.timer[0].set_rate(0%)
                current_object.timer[0].reset()
            end
        
            if current_object.timer[0] > 10 then
                current_object.delete()
            end
        end
    end
end

-- Checkpoint System